package hr.apartmentmanager.web.web;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Calendar;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.TimeZone;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.view.RedirectView;

import hr.apartmentmanager.enumerations.ReservationStatus;
import hr.apartmentmanager.web.model.Apartment;
import hr.apartmentmanager.web.model.Reservation;
import hr.apartmentmanager.web.model.Tourists;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/demo") // This means URL's start with /demo (after Application path)
public class MainController {
	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private ReservationRepository reservationRepository;
	
	@Autowired
	private ApartmentRepository apartmentRepository;
	
	@Autowired
	private TouristsRepository touristsRepository;
	

	@PostMapping(path = "/add") // Map ONLY POST Requests
	public @ResponseBody String addNewReservation(@RequestParam int reservationId, @RequestParam LocalDate checkInDate,
			@RequestParam LocalDate checkOutDate, @RequestParam double pricePerNight, @RequestParam double totalPrice,
			@RequestParam String confirmed, @RequestParam double advancedPayment, @RequestParam String advPayCurrency) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		ReservationStatus status = ReservationStatus.reservation;
		Reservation reservation = new Reservation(reservationId, checkInDate, checkOutDate, pricePerNight, totalPrice,
				advancedPayment, advPayCurrency, status);
		reservationRepository.save(reservation);
		return "Saved";
	}
	
	@GetMapping(path = "/all-apartments")
	public @ResponseBody Iterable<Apartment> getAllApartments() {
		// This returns a JSON or XML with the users
		return apartmentRepository.findAll();
	}
	
	
	@PostMapping(path = "/reservations/{id}")
	public RedirectView  getReservation(
			@PathVariable(required = true) Long id,
			@RequestParam("name") String touristsName,
			@RequestParam("apartmentId") int apartmentId,
			@RequestParam("checkInDate") String checkInDate,
			@RequestParam("persons") String numberOfPersons,
			@RequestParam("checkOutDate") String checkOutDate,
			@RequestParam("adults") String numberOfAdults,
			@RequestParam("pricePerNight") String pricePerNight,
			@RequestParam("children") String numberOfChildren,
			@RequestParam(name = "advancedPaymentPaid", required = false) String advancedPaymentPaid,
			@RequestParam("advancedPaymentCurrency") String advancedPaymentCurrency,
			@RequestParam("city") String city,
			@RequestParam("advancedPaymentAmount") String advancedPaymentAmount,
			@RequestParam("country") String country,
			@RequestParam("totalPrice") String totalPrice,
			@RequestParam("email") String email,
			@RequestParam("phone") String phone,
			@RequestParam(name = "pets", required = false) String pets,
			@RequestParam("notes") String notes
			) {
		
		if(advancedPaymentPaid==null)
			advancedPaymentPaid="no";
		if(pets==null)
			pets="no";
		boolean petsBool = pets.equals("no") ? false : true;
		
		Integer numberOfPersonsInt, numberOfAdultsInt, numberOfChildrenInt;
		try {
			numberOfPersonsInt = Integer.valueOf(numberOfPersons); 
		} catch (NumberFormatException exception) {
			numberOfPersonsInt = null;
		}
		try {
			numberOfAdultsInt = Integer.valueOf(numberOfAdults);
		} catch (NumberFormatException exception) {
			numberOfAdultsInt = null;
		}
		try {
			numberOfChildrenInt = Integer.valueOf(numberOfChildren); 
		} catch (NumberFormatException exception) {
			numberOfChildrenInt = null;
		}
		
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		LocalDate checkInDateLD = LocalDate.parse(checkInDate, formatter);
		LocalDate checkOutDateLD = LocalDate.parse(checkOutDate, formatter);
		
		BigDecimal pricePerNightBD, totalPriceBD, advancedPaymentAmountBD;
		try {
			pricePerNightBD = new BigDecimal(pricePerNight);
		} catch (NumberFormatException exception) {
			pricePerNightBD = null;
		}
		try {
			totalPriceBD = new BigDecimal(totalPrice);
		} catch (NumberFormatException exception) {
			totalPriceBD = pricePerNightBD.multiply(new BigDecimal(
					ChronoUnit.DAYS.between(checkInDateLD, checkOutDateLD)));
		}
		try {
			advancedPaymentAmountBD = 
					new BigDecimal(advancedPaymentAmount);
		} catch (NumberFormatException exception) {
			advancedPaymentAmountBD = null;
		}
		
		Optional<Reservation> optReservation = reservationRepository.findById(id);
		if(optReservation.isPresent()) {
			Tourists tourists = optReservation.get().getTourists();
			tourists.setName(touristsName);
			tourists.setNumberOfPersons(numberOfPersonsInt);
			tourists.setNumberOfAdults(numberOfAdultsInt);
			tourists.setNumberOfChildren(numberOfChildrenInt);
			tourists.setCity(city);
			tourists.setCountry(country);
			tourists.setEmail(email);
			tourists.setPhoneNumber(phone);
			tourists.setPets(petsBool);
			tourists.setTouristsNote(notes);
			
			Apartment apartment = apartmentRepository.findById(apartmentId).get();
			
			Reservation reservation = optReservation.get();
			reservation.setApartment(apartment);
			reservation.setCheckInDate(checkInDateLD);
			reservation.setCheckOutDate(checkOutDateLD);
			reservation.setPricePerNight(pricePerNightBD);
			reservation.setTotalPrice(totalPriceBD);
			reservation.setAdvPayCurrency(advancedPaymentCurrency);
			reservation.setAdvancedPayment(advancedPaymentAmountBD);
			
			touristsRepository.save(tourists);
			reservationRepository.save(reservation);
			return new RedirectView("/demo/reservations/" + id);
		}
		
		return new RedirectView("error");
				
	}
	
	@GetMapping(path = "/reservations")
	public ModelAndView getReservation() {
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		String user = (auth == null || auth.getName().equals("anonymousUser")) ?
				"Neregistrirani korisnik" : auth.getName(); 
	
		ModelAndView mav = new ModelAndView("reservations");
		mav.addObject("user", user);
		mav.addObject("reservations", reservationRepository.findAll());
		return mav;
	}
	
	@GetMapping(path = "/reservations/{id}")
	public ModelAndView getReservation(
			@PathVariable(required = true) Long id) {
		
		Optional<Reservation> reservationOpt = reservationRepository.findById(id);

		if(!reservationOpt.isPresent()) {
			return new ModelAndView("not-found");
		}
		
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		String user = (auth == null || auth.getName().equals("anonymousUser")) ?
				"Neregistrirani korisnik" : auth.getName(); 
		
		Reservation reservation = reservationOpt.get();
		ModelAndView mav = new ModelAndView("reservation");
		mav.addObject("user", user);
		mav.addObject("apartments", apartmentRepository.findAll());
		mav.addObject("reservation", reservation);
		return mav;
	}
	
	/*
	
	
	@GetMapping(path = "/logout")
	public RedirectView logout(HttpServletRequest request, HttpServletResponse response) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();  
        if (auth != null){      
           new SecurityContextLogoutHandler().logout(request, response, auth);  
        }  
		return new RedirectView("reserved-dates");
	}

	*/
	
	
	@GetMapping(path = "/login")
	public ModelAndView login() {
		return new ModelAndView("login");
	}
	
	
	@GetMapping(path = "/reserved-dates")
	public ModelAndView getReservedDates(@RequestParam(required = false) Integer month
			, @RequestParam(required = false) Integer year) {
		
		month = (month != null) ? month : Calendar.getInstance().get(Calendar.MONTH);
		year = (year != null) ? year : Calendar.getInstance().get(Calendar.YEAR);
		
		// This returns a JSON or XML with the users
		Set<Apartment> apartments = new LinkedHashSet<>();
		Iterable<Reservation> reservationRepositoryAll = reservationRepository.findAll();
		for(Reservation reservation : reservationRepositoryAll) {
			Apartment apartment;
			if(reservation.getApartment() != null) {
				apartment = reservation.getApartment();
				if(!apartments.contains(apartment)) {
					apartments.add(apartment);
				}
				final Apartment tmp = apartment;
				Optional<Apartment> foundApartment = apartments.stream().filter(other -> other.equals(tmp)).findFirst();
				apartment = foundApartment.get();
				//for(LocalDate date : reservation.getCheckInDate().datesUntil(reservation.getCheckOutDate()).collect(Collectors.toList()))
				for(LocalDate date : getDatesBetweenUsingJava8(reservation.getCheckInDate(), reservation.getCheckOutDate()))
					apartment.getApartmentReservations().put(date, reservation);
			}
		}
		
		LocalDate startOfMonth = LocalDate.of(year, month, 1);
		LocalDate startOfNextMonth = startOfMonth.plusMonths(1);
		
		List<LocalDate> monthToShow = getDatesBetweenUsingJava8(startOfMonth, startOfNextMonth);
		int[] months = {6, 7, 8, 9};
		int currentYear = Calendar.getInstance().get(Calendar.YEAR);
		int[] years = {currentYear-1, currentYear, currentYear+1}; 
		
		
		String user = getUserName();
		
		ModelAndView mav = new ModelAndView();
		mav.addObject("user", user);
		mav.addObject("yearsInt", years);
		mav.addObject("monthsInt", months);
		mav.addObject("apartments", apartments);
		mav.addObject("month", monthToShow);
        mav.setViewName("reserved-dates");
		return mav;
	}

	@GetMapping(path = "/apartments")
	public ModelAndView getApartments() {
		
		ModelAndView mav = new ModelAndView("apartments");
		mav.addObject("user", getUserName());
		mav.addObject("apartments", apartmentRepository.findAll());
		
		return mav;
	}
	
	@GetMapping(path = "/apartments/{id}")
	public ModelAndView getApartment(
			@PathVariable(required = true) Integer id) {
		
		Apartment apartment = apartmentRepository.findById(id).get();
		
		ModelAndView mav = new ModelAndView("apartment");
		mav.addObject("user", getUserName());
		mav.addObject("apartment", apartment);
		
		return mav;
	}

	@GetMapping(path = "/all-reservations")
	public @ResponseBody Iterable<Reservation> getAllReservatiosn() {
		// This returns a JSON or XML with the users
		return reservationRepository.findAll();
	}
	
	/*
	@GetMapping("/apartments")
	public String apart(@RequestParam(name = "name", required = false, defaultValue = "World") String name,
			Model model) {
		for (Apartment apartment : apartmentRepository.findAll()) {
			if(apartment != null)
				System.out.println(apartment.getApartmentName());

		}
		model.addAttribute("name", name);
		return "reservations";
	}
	*/
	
	@GetMapping(path="/reservations/new")
	private ModelAndView newReservation() {
		
		ModelAndView mav = new ModelAndView("new-reservation");
		mav.addObject("user", getUserName());
		mav.addObject("apartments", apartmentRepository.findAll());
		
		return mav;
	}
	
	@PostMapping(path="/reservations/new")
	private RedirectView saveNewReservation(
			@RequestParam("name") String touristsName,
			@RequestParam("apartmentId") String apartmentId,
			@RequestParam("checkInDate") String checkInDate,
			@RequestParam(name = "persons", required = false) String numberOfPersons,
			@RequestParam("checkOutDate") String checkOutDate,
			@RequestParam(name = "adults", required = false) String numberOfAdults,
			@RequestParam("pricePerNight") String pricePerNight,
			@RequestParam(name = "children", required = false) String numberOfChildren,
			@RequestParam(name = "advancedPaymentPaid", required = false) String advancedPaymentPaid,
			@RequestParam(name = "advancedPaymentCurrency", required = false) String advancedPaymentCurrency,
			@RequestParam(name = "city", required = false) String city,
			@RequestParam(name = "advancedPaymentAmount", required = false) String advancedPaymentAmount,
			@RequestParam(name = "country", required = false) String country,
			@RequestParam(name = "totalPrice", required = true) String totalPrice,
			@RequestParam(name = "email", required = false) String email,
			@RequestParam(name = "phone", required = false) String phone,
			@RequestParam(name = "pets", required = false) String pets,
			@RequestParam(name = "notes", required = false) String notes) {
		
		if(advancedPaymentPaid==null)
			advancedPaymentPaid="no";
		if(pets==null)
			pets="no";
		boolean petsBool = pets.equals("no") ? false : true;
		
		Integer numberOfPersonsInt, numberOfAdultsInt, numberOfChildrenInt;
		try {
			numberOfPersonsInt = Integer.valueOf(numberOfPersons); 
		} catch (NumberFormatException exception) {
			numberOfPersonsInt = null;
		}
		try {
			numberOfAdultsInt = Integer.valueOf(numberOfAdults);
		} catch (NumberFormatException exception) {
			numberOfAdultsInt = null;
		}
		try {
			numberOfChildrenInt = Integer.valueOf(numberOfChildren); 
		} catch (NumberFormatException exception) {
			numberOfChildrenInt = null;
		}
		
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		LocalDate checkInDateLD = LocalDate.parse(checkInDate, formatter);
		LocalDate checkOutDateLD = LocalDate.parse(checkOutDate, formatter);
		
		BigDecimal pricePerNightBD, totalPriceBD, advancedPaymentAmountBD;
		try {
			pricePerNightBD = new BigDecimal(pricePerNight);
		} catch (NumberFormatException exception) {
			pricePerNightBD = null;
		}
		try {
			totalPriceBD = new BigDecimal(totalPrice);
		} catch (NumberFormatException exception) {
			totalPriceBD = pricePerNightBD.multiply(new BigDecimal(
					ChronoUnit.DAYS.between(checkInDateLD, checkOutDateLD)));
		}
		try {
			advancedPaymentAmountBD = 
					new BigDecimal(advancedPaymentAmount);
		} catch (NumberFormatException exception) {
			advancedPaymentAmountBD = null;
		}
		
		Tourists tourists = new Tourists(touristsName, country, city,
				numberOfAdultsInt, numberOfChildrenInt
				, numberOfPersonsInt, email, phone, petsBool, notes);
		touristsRepository.save(tourists);
		
		Apartment apartment = apartmentRepository.findById(new Integer(apartmentId)).get();
		
		Reservation reservation = 
				new Reservation(tourists
						, apartment
						, checkInDateLD		// 1 day off could be problem occurs on all tests but not on deployment
						, checkOutDateLD	
						//, BigDecimal.valueOf(Double.parseDouble(pricePerNight))
						, pricePerNightBD
						//, BigDecimal.valueOf(Double.parseDouble(totalPrice))
						, totalPriceBD
						, ReservationStatus.reservation
						//, BigDecimal.valueOf(Double.parseDouble(advancedPaymentAmount))
						, advancedPaymentAmountBD
						, advancedPaymentCurrency);
		
		reservationRepository.save(reservation);
		
		return new RedirectView("/demo/reserved-dates");
	}
	
	private String getUserName() {
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		return (auth == null || auth.getName().equals("anonymousUser")) ?
				"Neregistrirani korisnik" : auth.getName(); 
	}
	
	public static List<LocalDate> getDatesBetweenUsingJava8(
			  LocalDate startDate, LocalDate endDate) { 
			  
			    long numOfDaysBetween = ChronoUnit.DAYS.between(startDate, endDate); 
			    return IntStream.iterate(0, i -> i + 1)
			      .limit(numOfDaysBetween)
			      .mapToObj(i -> startDate.plusDays(i))
			      .collect(Collectors.toList()); 
			}

}