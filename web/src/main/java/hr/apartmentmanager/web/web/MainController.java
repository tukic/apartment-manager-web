package hr.apartmentmanager.web.web;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.Calendar;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import hr.apartmentmanager.enumerations.ReservationStatus;
import hr.apartmentmanager.web.model.Apartment;
import hr.apartmentmanager.web.model.Reservation;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/demo") // This means URL's start with /demo (after Application path)
public class MainController {
	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private ReservationRepository reservationRepository;
	
	@Autowired
	private ApartmentRepository apartmentRepository;

	@PostMapping(path = "/add") // Map ONLY POST Requests
	public @ResponseBody String addNewReservation(@RequestParam int reservationId, @RequestParam LocalDate checkInDate,
			@RequestParam LocalDate checkOutDate, @RequestParam double pricePerNight, @RequestParam double totalPrice,
			@RequestParam String confirmed, @RequestParam double advancedPayment, @RequestParam String advPayCurrency) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		ReservationStatus status = ReservationStatus.reservation;
		Reservation reservation = new Reservation(reservationId, checkInDate, checkOutDate, pricePerNight, totalPrice,
				advancedPayment, advPayCurrency, status);
		reservationRepository.save(reservation);
		return "Saved";
	}
	
	@GetMapping(path = "/all-apartments")
	public @ResponseBody Iterable<Apartment> getAllApartments() {
		// This returns a JSON or XML with the users
		return apartmentRepository.findAll();
	}
	
	@GetMapping(path = "/reservation")
	public ModelAndView getReservation(
			@RequestParam(required = true) Long id) {
		
		Optional<Reservation> reservationOpt = reservationRepository.findById(id);

		if(!reservationOpt.isPresent()) {
			return new ModelAndView("not-found");
		}
		
		Reservation reservation = reservationOpt.get();
		ModelAndView mav = new ModelAndView("reservation");
		mav.addObject("apartments", apartmentRepository.findAll());
		mav.addObject("reservation", reservation);
		return mav;
	}
	
	@GetMapping(path = "/reserved-dates")
	public ModelAndView getReservedDates(@RequestParam(required = false) Integer month
			, @RequestParam(required = false) Integer year) {
		
		month = (month != null) ? month : Calendar.getInstance().get(Calendar.MONTH);
		year = (year != null) ? year : Calendar.getInstance().get(Calendar.YEAR);
		
		// This returns a JSON or XML with the users
		Set<Apartment> apartments = new LinkedHashSet<>();
		Iterable<Reservation> reservationRepositoryAll = reservationRepository.findAll();
		for(Reservation reservation : reservationRepositoryAll) {
			Apartment apartment;
			if(reservation.getApartment() != null) {
				apartment = reservation.getApartment();
				if(!apartments.contains(apartment)) {
					apartments.add(apartment);
				}
				final Apartment tmp = apartment;
				Optional<Apartment> foundApartment = apartments.stream().filter(other -> other.equals(tmp)).findFirst();
				apartment = foundApartment.get();
				//for(LocalDate date : reservation.getCheckInDate().datesUntil(reservation.getCheckOutDate()).collect(Collectors.toList()))
				for(LocalDate date : getDatesBetweenUsingJava8(reservation.getCheckInDate(), reservation.getCheckOutDate()))
					apartment.getApartmentReservations().put(date, reservation);
			}
		}
		
		for (Apartment apartment : apartments) {
			for(Entry<LocalDate, Reservation> reservationDate : apartment.getApartmentReservations().entrySet())  {
				System.out.println(reservationDate.getKey() +
						" -> " + apartment.getApartmentName() + " : " +
						reservationDate.getValue().getTourists().getName());
			}
		}
		
		LocalDate startOfMonth = LocalDate.of(year, month, 1);
		LocalDate startOfNextMonth = startOfMonth.plusMonths(1);
		
		List<LocalDate> monthToShow = getDatesBetweenUsingJava8(startOfMonth, startOfNextMonth);
		int[] months = {6, 7, 8, 9};
		int currentYear = Calendar.getInstance().get(Calendar.YEAR);
		int[] years = {currentYear-1, currentYear, currentYear+1}; 
		
		ModelAndView mav = new ModelAndView();
		mav.addObject("yearsInt", years);
		mav.addObject("monthsInt", months);
		mav.addObject("apartments", apartments);
		mav.addObject("month", monthToShow);
        mav.setViewName("reserved-dates");
		return mav;
	}

	@GetMapping(path = "/all-reservations")
	public @ResponseBody Iterable<Reservation> getAllReservatiosn() {
		// This returns a JSON or XML with the users
		return reservationRepository.findAll();
	}
	
	@GetMapping("/apartments")
	public String apart(@RequestParam(name = "name", required = false, defaultValue = "World") String name,
			Model model) {
		for (Apartment apartment : apartmentRepository.findAll()) {
			if(apartment != null)
				System.out.println(apartment.getApartmentName());

		}
		model.addAttribute("name", name);
		return "reservations";
	}
	
	public static List<LocalDate> getDatesBetweenUsingJava8(
			  LocalDate startDate, LocalDate endDate) { 
			  
			    long numOfDaysBetween = ChronoUnit.DAYS.between(startDate, endDate); 
			    return IntStream.iterate(0, i -> i + 1)
			      .limit(numOfDaysBetween)
			      .mapToObj(i -> startDate.plusDays(i))
			      .collect(Collectors.toList()); 
			}

}